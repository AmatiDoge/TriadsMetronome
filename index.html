```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Guitar Triad Voice-Leading Trainer (Strings 1–3)</title>
  <style>
    :root { color-scheme: light dark; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin:0; min-height:100vh; display:grid; place-items:center; padding:24px;
      background: Canvas; color: CanvasText;
    }
    .card{
      width:min(980px, 100%);
      border:1px solid color-mix(in oklab, CanvasText 20%, transparent);
      border-radius:18px; padding:18px 18px 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.10);
    }
    .top{ display:flex; gap:14px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap; }
    h1{ font-size:18px; margin:0 0 6px; letter-spacing:.2px;}
    .sub{ opacity:.8; font-size:13px; margin:0; line-height:1.35; }
    .grid{ display:grid; gap:12px; grid-template-columns: repeat(12, minmax(0,1fr)); margin-top:14px; }
    .field{
      grid-column: span 3;
      border:1px solid color-mix(in oklab, CanvasText 18%, transparent);
      border-radius:14px; padding:10px 10px 8px;
      background: color-mix(in oklab, Canvas 92%, CanvasText 8%);
    }
    .field.wide{ grid-column: span 6; }
    .field.tall{ grid-column: span 12; }
    .split{
      grid-column: span 12;
      display:grid;
      gap:12px;
      grid-template-columns: repeat(12, minmax(0,1fr));
    }
    .panel{
      border:1px solid color-mix(in oklab, CanvasText 18%, transparent);
      border-radius:14px; padding:12px;
      background: color-mix(in oklab, Canvas 92%, CanvasText 8%);
    }
    .panel.current{ grid-column: span 7; }
    .panel.next{ grid-column: span 5; }
    @media (max-width: 900px){
      .panel.current, .panel.next{ grid-column: span 12; }
    }

    label{ display:block; font-size:12px; opacity:.8; margin-bottom:6px; }
    select,input[type="number"]{ width:100%; }
    .row{ display:flex; gap:10px; align-items:center; }
    .btns{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    button{
      border:1px solid color-mix(in oklab, CanvasText 22%, transparent);
      background: color-mix(in oklab, Canvas 86%, CanvasText 14%);
      color: CanvasText;
      border-radius:12px; padding:10px 14px; font-weight:600; cursor:pointer;
    }
    button.primary{ background: color-mix(in oklab, CanvasText 18%, Canvas 82%); }
    button:disabled{ opacity:.6; cursor:not-allowed; }
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      border:1px solid color-mix(in oklab, CanvasText 20%, transparent);
      border-radius:999px; padding:8px 12px; font-size:12px; opacity:.95;
      background: color-mix(in oklab, Canvas 92%, CanvasText 8%);
    }
    .big{ font-size:28px; font-weight:800; margin:2px 0 2px; letter-spacing:.2px; }
    .inversion{
      font-size:22px;
      font-weight:800;
      margin: 6px 0 2px;
      letter-spacing: 0.3px;
    }
    .small{ font-size:13px; opacity:.85; margin:0; line-height:1.4;}
    .muted{ font-size:12px; opacity:.75; margin:0 0 8px; }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      padding:2px 8px; border-radius:8px;
      border:1px solid color-mix(in oklab, CanvasText 22%, transparent);
      background: color-mix(in oklab, Canvas 88%, CanvasText 12%);
      font-size:12px;
    }
    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      white-space: pre-wrap;
      word-break: break-word;
      border:1px dashed color-mix(in oklab, CanvasText 25%, transparent);
      border-radius:14px;
      padding:12px;
      background: color-mix(in oklab, Canvas 94%, CanvasText 6%);
    }
    .hint{ font-size:12px; opacity:.75; margin-top:6px; }
    .checkbox{ display:flex; gap:10px; align-items:center; font-size:13px; opacity:.9; user-select:none; }
    input[type="checkbox"]{ transform: translateY(1px); }
    @media (max-width: 820px){
      .field{ grid-column: span 6; }
      .field.wide{ grid-column: span 12; }
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="top">
      <div>
        <h1>Guitar Minimal-Movement Triads (Strings 1–2–3 only)</h1>
        <p class="sub">
          Every 4 beats: choose a <span class="kbd">diatonic triad</span> in the selected <span class="kbd">Key</span>/<span class="kbd">Mode</span>,
          and pick the <span class="kbd">root / 1st / 2nd inversion</span> voicing on strings <span class="kbd">1–2–3</span>
          that minimizes total fret movement while staying in a tight position.
          The <span class="kbd">next chord</span> is always visible.
        </p>
      </div>
      <div class="btns">
        <button id="startBtn" class="primary">Start</button>
        <button id="stopBtn" disabled>Stop</button>
        <span class="pill">Beat: <span id="beatReadout" class="kbd">–</span></span>
        <span class="pill">Bar: <span id="barReadout" class="kbd">–</span></span>
      </div>
    </div>

    <div class="grid">
      <div class="field">
        <label for="keySel">Key</label>
        <select id="keySel"></select>
        <div class="hint">All 12 keys.</div>
      </div>

      <div class="field">
        <label for="modeSel">Mode</label>
        <select id="modeSel">
          <option value="major">Major</option>
          <option value="natural_minor">Natural minor</option>
        </select>
        <div class="hint">Diatonic triads.</div>
      </div>

      <div class="field">
        <label for="bpm">BPM</label>
        <input id="bpm" type="number" min="30" max="260" value="92" step="1" />
        <div class="hint">Metronome speed.</div>
      </div>

      <div class="field">
        <label for="accentSel">Click accent</label>
        <select id="accentSel">
          <option value="bar">Accent beat 1</option>
          <option value="none">No accent</option>
        </select>
        <div class="hint">Louder on beat 1.</div>
      </div>

      <div class="field wide">
        <label>Guitar position constraints (strings 1–2–3)</label>
        <div class="row">
          <div style="flex:1">
            <label for="minFret" style="margin:0 0 6px">Min fret</label>
            <input id="minFret" type="number" min="0" max="22" value="0" />
          </div>
          <div style="flex:1">
            <label for="maxFret" style="margin:0 0 6px">Max fret</label>
            <input id="maxFret" type="number" min="0" max="24" value="12" />
          </div>
          <div style="flex:1">
            <label for="maxSpan" style="margin:0 0 6px">Max fret span</label>
            <input id="maxSpan" type="number" min="2" max="8" value="4" />
          </div>
        </div>
        <div class="hint">
          “Close in position” = within <span class="kbd">max span</span> frets from lowest to highest note (all three strings).
        </div>
      </div>

      <div class="field">
        <label>Sound</label>
        <div class="checkbox"><input id="clickOn" type="checkbox" checked /> Metronome click</div>
        <div class="checkbox"><input id="chordOn" type="checkbox" /> Play triad on bar (short)</div>
        <div class="hint">Press Start once to enable audio.</div>
      </div>

      <!-- CURRENT + NEXT panels -->
      <div class="split">
        <div class="panel current">
          <div class="muted">CURRENT (play now)</div>
          <div class="big" id="chordTitle">Ready</div>
          <div class="inversion" id="inversionText">–</div>
          <p class="small" id="chordSubtitle">Press Start (or Space).</p>
        </div>

        <div class="panel next">
          <div class="muted">NEXT (coming up)</div>
          <div class="big" id="nextChordTitle">–</div>
          <div class="inversion" id="nextInversionText">–</div>
          <p class="small" id="nextChordSubtitle">–</p>
          <div class="hint">Next chord is pre-selected and shown immediately after each change.</div>
        </div>
      </div>

      <div class="field tall">
        <label>Frets (String 3 → 2 → 1) + movement</label>
        <div class="mono" id="debug">–</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- Theory ----------
  const NOTE_NAMES_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const ROMAN_MAJOR = ["I","ii","iii","IV","V","vi","vii°"];
  const ROMAN_NMIN  = ["i","ii°","III","iv","v","VI","VII"];
  const SCALE_MAJOR = [0,2,4,5,7,9,11];
  const SCALE_NMIN  = [0,2,3,5,7,8,10];

  const pc = n => ((n % 12) + 12) % 12;

  // Strings 1–3 only (standard tuning):
  // String 1 = E4 (MIDI 64), String 2 = B3 (59), String 3 = G3 (55)
  const OPEN_MIDI = { s1: 64, s2: 59, s3: 55 };

  function midiToName(m){
    const name = NOTE_NAMES_SHARP[pc(m)];
    const oct = Math.floor(m/12) - 1;
    return `${name}${oct}`;
  }
  function noteNameFromPc(p){ return NOTE_NAMES_SHARP[pc(p)]; }

  function triadFromScale(scaleSemis, degreeIndex){
    const deg = (i) => scaleSemis[(degreeIndex + i) % 7];
    return [deg(0), deg(2), deg(4)];
  }

  function chordQuality(rootPc, thirdPc, fifthPc){
    const i3 = pc(thirdPc - rootPc);
    const i5 = pc(fifthPc - rootPc);
    if (i3 === 4 && i5 === 7) return "maj";
    if (i3 === 3 && i5 === 7) return "min";
    if (i3 === 3 && i5 === 6) return "dim";
    if (i3 === 4 && i5 === 8) return "aug";
    return "triad";
  }

  function chordName(tonicPc, triadRel){
    const root = pc(tonicPc + triadRel[0]);
    const third = pc(tonicPc + triadRel[1]);
    const fifth = pc(tonicPc + triadRel[2]);
    const qual = chordQuality(root, third, fifth);
    const rootName = NOTE_NAMES_SHARP[root];
    if (qual === "maj") return rootName;
    if (qual === "min") return rootName + "m";
    if (qual === "dim") return rootName + "dim";
    if (qual === "aug") return rootName + "aug";
    return rootName;
  }

  function diatonicTriads(mode){
    const scale = (mode === "major") ? SCALE_MAJOR : SCALE_NMIN;
    return Array.from({length:7}, (_,deg) => triadFromScale(scale, deg));
  }

  // ---------- Guitar voicings on strings 3–2–1 ----------
  function midiForStringFret(str, fret){
    const open = (str === 1) ? OPEN_MIDI.s1 : (str === 2 ? OPEN_MIDI.s2 : OPEN_MIDI.s3);
    return open + fret;
  }

  function inversionFromBassPc(chordAbsPcs, bassPc){
    const [r, t, f] = chordAbsPcs;
    if (pc(bassPc) === pc(r)) return 0;
    if (pc(bassPc) === pc(t)) return 1;
    if (pc(bassPc) === pc(f)) return 2;
    return null;
  }

  function generateTriadVoicingsOn123(chordAbsPcs, minFret, maxFret, maxSpan){
    const chordSet = new Set(chordAbsPcs.map(pc));
    const results = [];

    for (let f3 = minFret; f3 <= maxFret; f3++){
      const m3 = midiForStringFret(3, f3);
      if (!chordSet.has(pc(m3))) continue;

      for (let f2 = minFret; f2 <= maxFret; f2++){
        const m2 = midiForStringFret(2, f2);
        if (!chordSet.has(pc(m2))) continue;

        for (let f1 = minFret; f1 <= maxFret; f1++){
          const m1 = midiForStringFret(1, f1);
          if (!chordSet.has(pc(m1))) continue;

          const pcsUsed = [pc(m3), pc(m2), pc(m1)];
          const uniq = new Set(pcsUsed);
          if (uniq.size !== 3) continue; // no doubling

          const lo = Math.min(f3,f2,f1);
          const hi = Math.max(f3,f2,f1);
          if ((hi - lo) > maxSpan) continue; // close position

          if (!(m3 < m2 && m2 < m1)) continue; // ascending pitch by string

          const inv = inversionFromBassPc(chordAbsPcs, pc(m3));
          if (inv == null) continue;

          results.push({ frets:[f3,f2,f1], midis:[m3,m2,m1], inv });
        }
      }
    }
    return results;
  }

  function voicingCost(prevFrets, nextFrets){
    if (!prevFrets) return 0;
    const move =
      Math.abs(nextFrets[0]-prevFrets[0]) +
      Math.abs(nextFrets[1]-prevFrets[1]) +
      Math.abs(nextFrets[2]-prevFrets[2]);

    const prevPos = Math.min(...prevFrets);
    const nextPos = Math.min(...nextFrets);
    const shiftPenalty = 0.35 * Math.abs(nextPos - prevPos);
    return move + shiftPenalty;
  }

  function pickBestVoicing(chordAbsPcs, prevFrets, minFret, maxFret, maxSpan){
    const all = generateTriadVoicingsOn123(chordAbsPcs, minFret, maxFret, maxSpan);
    if (all.length === 0) return { best:null, tried:0, cost:Infinity };

    let best = all[0];
    let bestC = voicingCost(prevFrets, best.frets);
    for (const v of all){
      const c = voicingCost(prevFrets, v.frets);
      if (c < bestC){
        best = v;
        bestC = c;
      }
    }
    return { best, tried:all.length, cost:bestC };
  }

  // ---------- Chord choice (diatonic) ----------
  function chooseNextDegree(prevDeg){
    const w = [1,1,1,1,1,1,1];
    if (prevDeg != null){
      w[prevDeg] = 0.35;
      w[(prevDeg+1)%7] += 0.25;
      w[(prevDeg+6)%7] += 0.25;
    }
    const sum = w.reduce((a,b)=>a+b,0);
    let r = Math.random()*sum;
    for (let i=0;i<7;i++){
      r -= w[i];
      if (r <= 0) return i;
    }
    return Math.floor(Math.random()*7);
  }

  // ---------- Audio ----------
  let audioCtx = null;
  function ensureAudio(){
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    return audioCtx;
  }

  function clickSound(time, accented){
    const ctx = ensureAudio();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = "square";
    osc.frequency.value = accented ? 1800 : 1200;
    gain.gain.value = 0.0001;
    osc.connect(gain).connect(ctx.destination);

    const t0 = time;
    gain.gain.setValueAtTime(0.0001, t0);
    gain.gain.exponentialRampToValueAtTime(accented ? 0.12 : 0.08, t0 + 0.001);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.03);
    osc.start(t0);
    osc.stop(t0 + 0.04);
  }

  function playTriad(time, midiNotes){
    const ctx = ensureAudio();
    const out = ctx.createGain();
    out.gain.value = 0.10;
    out.connect(ctx.destination);

    for (const m of midiNotes){
      const osc = ctx.createOscillator();
      const g = ctx.createGain();
      osc.type = "sine";
      osc.frequency.value = 440 * Math.pow(2, (m - 69) / 12);
      g.gain.value = 0.0001;
      osc.connect(g).connect(out);

      g.gain.setValueAtTime(0.0001, time);
      g.gain.exponentialRampToValueAtTime(0.15, time + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, time + 0.28);

      osc.start(time);
      osc.stop(time + 0.30);
    }
  }

  // ---------- UI ----------
  const keySel = document.getElementById("keySel");
  const modeSel = document.getElementById("modeSel");
  const bpmEl = document.getElementById("bpm");
  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const beatReadout = document.getElementById("beatReadout");
  const barReadout = document.getElementById("barReadout");

  const chordTitle = document.getElementById("chordTitle");
  const inversionText = document.getElementById("inversionText");
  const chordSubtitle = document.getElementById("chordSubtitle");

  const nextChordTitle = document.getElementById("nextChordTitle");
  const nextInversionText = document.getElementById("nextInversionText");
  const nextChordSubtitle = document.getElementById("nextChordSubtitle");

  const debugEl = document.getElementById("debug");
  const clickOn = document.getElementById("clickOn");
  const chordOn = document.getElementById("chordOn");
  const accentSel = document.getElementById("accentSel");

  const minFretEl = document.getElementById("minFret");
  const maxFretEl = document.getElementById("maxFret");
  const maxSpanEl = document.getElementById("maxSpan");

  NOTE_NAMES_SHARP.forEach((n, i) => {
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = n;
    keySel.appendChild(opt);
  });
  keySel.value = "0";

  function clampConstraints(){
    let minF = Number(minFretEl.value);
    let maxF = Number(maxFretEl.value);
    let span = Number(maxSpanEl.value);

    if (Number.isNaN(minF)) minF = 0;
    if (Number.isNaN(maxF)) maxF = 12;
    if (Number.isNaN(span)) span = 4;

    minF = Math.max(0, Math.min(22, minF));
    maxF = Math.max(0, Math.min(24, maxF));
    if (maxF < minF) maxF = minF;

    span = Math.max(2, Math.min(8, span));

    minFretEl.value = String(minF);
    maxFretEl.value = String(maxF);
    maxSpanEl.value = String(span);

    return { minF, maxF, span };
  }

  // ---------- Runtime / Scheduler ----------
  let isRunning = false;
  let nextNoteTime = 0.0;
  let timerID = null;
  const lookahead = 25.0;
  const scheduleAheadTime = 0.10;

  let beatInBar = 0; // 0..3
  let barCount = 0;

  // Musical state
  let tonicPc = 0;
  let mode = "major";
  let triads = diatonicTriads(mode);

  // CURRENT state (what you're playing now)
  let currentDegree = null;
  let currentVoicing = null; // {frets, midis, inv}

  // NEXT state (always visible)
  let nextDegree = null;
  let nextVoicing = null;    // best voicing chosen based on currentVoicing

  function setKeyModeFromUI(){
    tonicPc = Number(keySel.value);
    mode = modeSel.value;
    triads = diatonicTriads(mode);
  }

  function inversionLabel(inv){
    if (inv === 0) return "ROOT POSITION";
    if (inv === 1) return "1st INVERSION";
    if (inv === 2) return "2nd INVERSION";
    return "—";
  }

  function formatChordPanel(deg, voicing, titleEl, invEl, subEl){
    if (deg == null){
      titleEl.textContent = "–";
      invEl.textContent = "–";
      subEl.textContent = "–";
      return;
    }
    const roman = (mode === "major") ? ROMAN_MAJOR[deg] : ROMAN_NMIN[deg];
    const name = chordName(tonicPc, triads[deg]);

    if (!voicing){
      titleEl.textContent = `${name} (${roman})`;
      invEl.textContent = "—";
      subEl.textContent = "No playable voicing in window.";
      return;
    }

    const [f3,f2,f1] = voicing.frets;
    titleEl.textContent = `${name} (${roman})`;
    invEl.textContent = inversionLabel(voicing.inv);
    subEl.textContent = `frets (G–B–E): ${f3}–${f2}–${f1}`;
  }

  function computeNextFromCurrent(){
    const { minF, maxF, span } = clampConstraints();
    const prevFrets = currentVoicing ? currentVoicing.frets : null;

    const deg = chooseNextDegree(currentDegree);
    const chordAbsPcs = triads[deg].map(x => pc(tonicPc + x));
    const { best } = pickBestVoicing(chordAbsPcs, prevFrets, minF, maxF, span);

    nextDegree = deg;
    nextVoicing = best;
    formatChordPanel(nextDegree, nextVoicing, nextChordTitle, nextInversionText, nextChordSubtitle);
  }

  function applyNextAsCurrent(){
    currentDegree = nextDegree;
    currentVoicing = nextVoicing;

    formatChordPanel(currentDegree, currentVoicing, chordTitle, inversionText, chordSubtitle);

    // Debug info
    if (!currentVoicing){
      debugEl.textContent = "No playable voicing found. Adjust fret window/span.";
    } else {
      const [f3,f2,f1] = currentVoicing.frets;
      const [m3,m2,m1] = currentVoicing.midis;

      const move = (currentVoicing && nextVoicing && currentVoicing !== nextVoicing) ? 0 : 0; // placeholder; we show real move below
      const spanNow = Math.max(f1,f2,f3) - Math.min(f1,f2,f3);
      const { span } = clampConstraints();

      debugEl.textContent =
`Key: ${NOTE_NAMES_SHARP[tonicPc]} · Mode: ${mode.replace("_"," ")}
Strings fixed: 3(G) → 2(B) → 1(E)
Notes: ${midiToName(m3)} | ${midiToName(m2)} | ${midiToName(m1)}
Frets: ${f3} | ${f2} | ${f1}
Close-position span: ${spanNow} (limit ${span})
Next chord is shown on the right.`;
    }

    // Optional chord sound on downbeat
    if (chordOn.checked && currentVoicing && audioCtx){
      playTriad(nextNoteTime, currentVoicing.midis);
    }

    // Immediately compute and display the next chord
    computeNextFromCurrent();
  }

  // ---------- Beat scheduling ----------
  function nextBeat(){
    const bpm = Math.max(30, Math.min(260, Number(bpmEl.value) || 92));
    const secondsPerBeat = 60.0 / bpm;
    nextNoteTime += secondsPerBeat;

    beatInBar = (beatInBar + 1) % 4;
    if (beatInBar === 0) barCount += 1;

    beatReadout.textContent = String(beatInBar + 1);
    barReadout.textContent = String(barCount + 1);

    // On downbeat (beat 1): promote NEXT -> CURRENT, then generate a new NEXT
    if (beatInBar === 0){
      applyNextAsCurrent();
    }
  }

  function scheduleBeat(time, beatNumberInBar){
    if (!clickOn.checked) return;
    const accented = (accentSel.value === "bar") && (beatNumberInBar === 0);
    clickSound(time, accented);
  }

  function scheduler(){
    if (!audioCtx) return;
    while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime){
      scheduleBeat(nextNoteTime, beatInBar);
      nextBeat();
    }
  }

  // ---------- Start/Stop ----------
  function start(){
    if (isRunning) return;
    setKeyModeFromUI();
    clampConstraints();
    ensureAudio();
    if (audioCtx.state === "suspended") audioCtx.resume();

    isRunning = true;
    startBtn.disabled = true;
    stopBtn.disabled = false;

    beatInBar = 3; // so first nextBeat -> 0 (downbeat)
    barCount = 0;

    currentDegree = null;
    currentVoicing = null;

    // Precompute NEXT immediately so it is always visible from the start
    nextDegree = null;
    nextVoicing = null;
    formatChordPanel(null, null, chordTitle, inversionText, chordSubtitle);
    formatChordPanel(null, null, nextChordTitle, nextInversionText, nextChordSubtitle);

    nextNoteTime = audioCtx.currentTime + 0.05;

    // Set an initial "next" using no previous frets (free choice in window),
    // then on the first downbeat it becomes current.
    computeNextFromCurrent();

    debugEl.textContent = "Running… next chord is visible on the right.";

    timerID = setInterval(scheduler, lookahead);
  }

  function stop(){
    if (!isRunning) return;
    isRunning = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    if (timerID) clearInterval(timerID);
    timerID = null;

    beatReadout.textContent = "–";
    barReadout.textContent = "–";

    chordTitle.textContent = "Stopped";
    inversionText.textContent = "—";
    chordSubtitle.textContent = "Press Start (or Space).";

    nextChordTitle.textContent = "—";
    nextInversionText.textContent = "—";
    nextChordSubtitle.textContent = "—";
  }

  startBtn.addEventListener("click", start);
  stopBtn.addEventListener("click", stop);

  keySel.addEventListener("change", () => { if (!isRunning) setKeyModeFromUI(); });
  modeSel.addEventListener("change", () => { if (!isRunning) setKeyModeFromUI(); });

  [minFretEl, maxFretEl, maxSpanEl].forEach(el => el.addEventListener("change", () => {
    clampConstraints();
    if (isRunning){
      // re-evaluate NEXT immediately with new constraints
      computeNextFromCurrent();
    }
  }));

  window.addEventListener("keydown", (e) => {
    if (e.code === "Space"){
      e.preventDefault();
      isRunning ? stop() : start();
    }
  });
})();
</script>
</body>
</html>
```
